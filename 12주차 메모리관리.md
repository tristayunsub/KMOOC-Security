메모리 관리 및 취약점,버퍼오버플로우
===

레지스터, 주기억장치, 보조기억장치. 
레지스터는 cpu의 일부. cpu의 동작속도와 동기화돼서 상당히 빠르게 작동. 주기억장치는 cpu에 직접 접근이 가능한 메모리
보조기억장치 cpu에 직접읽는다 

**메모리의 위치와 메모리 주소 개념**
각각의 주소에는 8비트의 데이터를 저장할수있도록 되어있다. 각각의 주소는 특정 메모리 위치에 대한 고유 식별자

컴퓨터가 메모리 위치를 식별하는 과정 **주소지정**

메모리 주소가 8비트라고 했을때. 중간에 00000100 한 6개의 공간을 가지고있을떄
처음에는 비어있다. 1011011이라는 데이터를 00000111 주소에 넣는다.

주소          메모리

00000111      1011011

어떠한 식으로 메모리에 여러가지 값들이 저장되나

**하나는 데이터영역이 필요하다.** 

프로그램에 필요한 전체적으로 사용되는 여러가지 변수들

프로그램에 사용되는 전역변수들이있고 이를 사용하기위해 할당되는것.

이러한 데이터영역은 프로그램의 시작과 동시에 할당.

데이터 영역에 대한 다양한 전역변수 같은 데이터를 저장.

프로그램이 종료되면 소멸된다.


**스택 영역**
함수 변수 저장, 함수 호출시 생성, 함수 완료시 소멸


**메모리 구조**
*힙영역- 필요에 의해 동적으로 메모리 할당*

메모리 구조 모습

STACK

HEAP

DATA

TEXT  위로올라간다~

스택영역은 높은주소에서 낮은주소로. 꺼꾸로 자라난다.

Stack 영역에는 
*Ret(Return Address), SFP(Stack Pointer), 변수1,2 메모리 주소가 높은 것 부터 낮은 것 순서대로 변수1과 2가 할당*

data 영역에서는

메모리의 낮은주소부터. 변수 3 4 5 6


변수들이 어떤 방식으로 메모리에 할당되는지보자

Main() {
int a=1;
int b=2;
int c=3;
int d=4;
}
ini i=77;

변수의 메모리주소: 0xbffffb44
변수의크기: 4byte
변수에 저장된 값: 77

우리가 a,b,c,d, 순서로 변수를 지정했따. 그런데 나중에들어온변수 즉 d가 가장 낮은 주소가 할당되어있다는 것을 눈여겨 봐야한다.

변수1에 임의로 4byte보다 큰 값을 입력 -> 할당되지 않은 영역 사용 가능

다른 영역까지사용하게 되는 취약점 존재

- - -


**버퍼 오버플로**


취약한 특정 함수 사용, 메모리 취약 부분 발견
하지만 언제 발승하냐. 
사용자 입력 요구시. 
이미 정해져있는 데이터를입력으로 받는 것이아니라 사용자가 임의의 값을 입력할수잇또록 해놓은 부분이 있을때

사용자가 10글자 사용하겠지 예상하고 프로그래밍 짰는데 20글자써버린다.
즉 스택과 힙 프로그램이 진행되면서 자라날수있는 공간에 주로 공격대상

**stack 오버플로우.**


지역변수,인자, 그다음에 함수가 종료된뒤에 돌아가서 return값.

특히 return값.

*입력값 조작, 관리자 권한 획득, 프로그램조작*


**힙 오버플로**
malloc이나 calloc같은 함수를 사용해서 
프로그래머가 직접적으로 공간에 여러가지 데이터를 할당하게된다.
버퍼 오버플로 이해


Main() {
cchar name
char school
printf("학교가 어딘가요
gets(name)
printf(대학인가요)
gets(SCHOOL)
printf("제가 다니는 학교는 %s)

여기서 중요한건 gets name , gets school 
키보드로 부터 문자열을 입력받아서 지정된 버퍼에 저장하는 함수가된다 .
문제는 비정상적 값 입력
여러 개의 변수 선언
30개를 name 배열에 넣음 
그럼 버퍼오버 플로 발생


버퍼오버플로 실습
===



